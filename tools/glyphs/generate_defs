#!/usr/bin/env python3
import argparse
import ast
import json
import sys
import textwrap
from dataclasses import dataclass
from functools import lru_cache
from pathlib import Path

# pip install rectpack numpy lark Pillow
import numpy as np
import rectpack
from lark import Discard, Lark, Transformer
from PIL import Image

# HACK: Ensure the shared module is visible for this script.
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))

from shared.glyph_mapping import CombineSource, Glyph, get_glyph_map
from shared.paths import PROJECT_PATHS, REPO_DIR, SHARED_SRC_DIR


def pack_sprites(
    glyphs: list[Glyph],
    output_dir: Path,
    page_size: int = 256,
    padding: int = 1,
):
    """Create packed images with the glyph sprites, and a mapping JSON for the
    injector that will later convert them into a .bin injection file.
    """
    glyph_with_sources = {
        glyph.source.index: (glyph, glyph.source)
        for glyph in glyphs
        if glyph.source.has_own_index
    }

    packer = rectpack.newPacker(rotation=False)
    for sprite_index, (glyph, source) in glyph_with_sources.items():
        pixels, _ = source.load()
        height, width, _ = pixels.shape
        packer.add_rect(width + padding * 2, height + padding * 2, sprite_index)
    packer.add_bin(page_size, page_size, count=float("inf"))
    packer.pack()

    injector_mappings: list[dict] = []
    for dst_page_num, bin in enumerate(packer):
        output_path = output_dir / f"alpha_sprites_{dst_page_num:02d}.png"
        dst_pixels = np.zeros((page_size, page_size, 4))

        for rect in bin:
            dst_x = rect.x + padding
            dst_y = rect.y + padding
            width = rect.width - padding * 2
            height = rect.height - padding * 2
            glyph, source = glyph_with_sources[rect.rid]

            pixels, bbox = source.load()

            dst_pixels[
                dst_y : dst_y + height,
                dst_x : dst_x + width,
            ] = pixels

            injector_mappings.append(
                {
                    "mesh_num": source.index,
                    "filename": output_path.name,
                    "x": dst_x,
                    "y": dst_y,
                    "w": width,
                    "h": height,
                    "l": bbox.x + glyph.extra_x,
                    "t": bbox.y + glyph.extra_y,
                    "b": bbox.y + glyph.extra_y + bbox.h,
                    "r": bbox.x + glyph.extra_x + bbox.w,
                }
            )

        image = Image.fromarray(dst_pixels.astype("uint8"), "RGBA")
        image.save(output_path)
        print("Created a sprite sheet for injector in", output_path)

    output_path = output_dir / "glyph_info.json"
    output_path.write_text(json.dumps(injector_mappings))
    print("Saved mappings for injector to", output_path)


def generate_def_file(output_path: Path, glyphs: list[Glyph]):
    """Generate a .def file for the game itself, with the C macros containing
    information on how to render each glyph.
    """
    header = textwrap.dedent(
        r"""
        // This file is autogenerated. See tools/glyphs/generate_defs for details.

        GLYPH_DEFINE("\n", GLYPH_NEWLINE, 0, -1)
        GLYPH_DEFINE(" ", GLYPH_SPACE, 0, -1)
        """
    ).strip()

    with output_path.open("w") as handle:
        print(header, file=handle)

        for glyph in glyphs:
            args = [
                json.dumps(glyph.text, ensure_ascii=False),
                {
                    "N": "GLYPH_NORMAL",
                    "c": "GLYPH_COMBINING",
                    "C": "GLYPH_COMPOUND",
                }[glyph.glyph_class],
                str(glyph.get_width()),
                str(glyph.source.index),
            ]

            if isinstance(glyph.source, CombineSource):
                assert glyph.glyph_class == "C", f"{glyph} has wrong class"
                offset_x, offset_y = glyph.source.get_offset()
                args.append(
                    ".combine_with = {.mesh_idx = %d, .offset_x = %d, .offset_y = %d}"
                    % (glyph.source.glyph2_source.index, offset_x, offset_y)
                )
            else:
                assert glyph.glyph_class != "C", f"{glyph} has wrong class"

            print("GLYPH_DEFINE(" + ", ".join(args) + ")", file=handle)

    print("Saved", output_path)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser()
    parser.add_argument("game", type=int)
    parser.add_argument("--injector-output-dir", type=Path, default=REPO_DIR)
    return parser.parse_args()


def main() -> None:
    args = parse_args()

    def_path = SHARED_SRC_DIR / f"game/text_tr{args.game}.def"
    input_dir = PROJECT_PATHS[args.game].data_dir / "glyphs"
    injector_output_dir = args.injector_output_dir

    glyphs = get_glyph_map(input_dir)

    pack_sprites(glyphs, output_dir=injector_output_dir)
    generate_def_file(def_path, glyphs)


if __name__ == "__main__":
    main()
